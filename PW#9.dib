#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения команды потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

global using System;
global using System.Collections.Concurrent;
global using System.Threading;
using System.ComponentModel.Design;
using System.Diagnostics;

public interface ICommand
{
    void Execute();
}

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}
public class ExceptionHandler
{
    public static void FindException(ICommand command, Exception exception)
    {
        Console.WriteLine($"Найдено исключение в команде: {command}, Ошибка: {exception.Message}");
    }
}
public class Round_Robin : IScheduler
{
    private ConcurrentQueue<ICommand> command_queue = new ConcurrentQueue<ICommand>();
    public bool HasCommand()
    {
        return command_queue.Count > 0;
    }
    public ICommand Select()
    {
        if (command_queue.TryDequeue(out ICommand command))
        {
            return command;
        }
        return null;
    }
    public void Add(ICommand command)
    {
        command_queue.Enqueue(command);
    }
}
public class ServerThread
{
    static bool thread_complete_hard = false;
    static bool thread_complete_soft = false;
    static IScheduler Scheduler;
    static AutoResetEvent next_command = new AutoResetEvent(false);
    static ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();
    public ServerThread(IScheduler scheduler)
    {
        Scheduler = scheduler;
    }
    private Thread thread = new Thread(() =>
    {
        while (true)
        {
            ICommand command=null;
            if (Scheduler.HasCommand())
            {
                command = Scheduler.Select();
            }
            else if(commands.Count > 0)
            {
                commands.TryDequeue(out command);
            }
            if(command!=null)
            {
                try
                {
                    command.Execute();
                    if (thread_complete_hard)
                    { break; }
                }
                catch (Exception exception)
                {
                    ExceptionHandler.FindException(command, exception);
                }
            }
            else if (command==null&& !thread_complete_soft)
            {
                next_command.WaitOne();
            }
            else if (command==null && thread_complete_soft)
            {
                break;
            }
        }
    });
    public void Start()
    {
        thread.Start();
    }
    public void AddComand(ICommand command)
    {
        Scheduler.Add(command);
        next_command.Set();
    }
    public void Hard()
    {
        if (Thread.CurrentThread == thread)
        {
            thread_complete_hard = true;
            next_command.Set();
        }
        else
        {
            throw new Exception("Команда не выполняется в текущем потоке");
        }

    }
    public void Soft()
    {

        if (Thread.CurrentThread == thread)
        {
            thread_complete_soft = true;
            next_command.Set();
        }
        else
        {
            throw new Exception("Команда не выполняется в текущем потоке");
        }

    }
}
public class TestCommand(int id, int maxExecutions) : ICommand
{
    int counter = 0;
    int id=id;
    int maxExecutions=maxExecutions;
    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
        if (counter < maxExecutions)
            scheduler.Add(this);
    }
}
public class HardStop(ServerThread server) : ICommand
{
    ServerThread server_thread=server;
    public void Execute()
    {
        server_thread.Hard();
    }
}
    public static IScheduler scheduler = new Round_Robin();
    public static void Test()
    {
        ServerThread server_1 = new ServerThread(scheduler);
        server_1.Start();
        
        for (int i = 0; i < 5; i++)
        {
            scheduler.Add(new TestCommand(Thread.CurrentThread.ManagedThreadId, 3));
        }
        Thread.Sleep(1000);
        server_1.AddComand(new HardStop(server_1));
    }
    Test();
    
#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
