#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерфейс ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public class ExceptionHandler
{
    public static void FindException(ICommand command, Exception exception)
    {
        Console.WriteLine($"Найдено исключение в команде: {command}, Ошибка: {exception.Message}");
    }
}
public class ServerThread
{
    static bool thread_complete_hard = false;
    static bool thread_complete_soft = false;
    static ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();
    static AutoResetEvent next_command = new AutoResetEvent(false);

    static Thread thread = new Thread(() =>
    {
        while (true)
        {
            if (commands.Count != 0)
            {
                commands.TryDequeue(out ICommand command);
                try
                {
                    command.Execute(); //выполнение команды
                    if (thread_complete_hard)
                        break; 
                }
                catch (Exception exception)
                {
                    ExceptionHandler.FindException(command, exception);
                }
            }
            else if (commands.Count == 0 && !thread_complete_soft)
                next_command.WaitOne();//ждёт сигнал о добавлении команды в очередь
                
            else if (commands.Count == 0 && thread_complete_soft)
                break;
        }
    });

    public void Start()
    {
        thread.Start();
    }

    public void AddComand(ICommand command)
    {
        commands.Enqueue(command);
        next_command.Set();//посылает сигнал о добавлении экземпляра в очередь
    }

    public void Hard()
    {
        if (Thread.CurrentThread == thread) //сверяет текущий и созданный поток
        {
            thread_complete_hard = true;
        }
        else
        {
            throw new Exception("Команда не выполняется в текущем потоке");
        }
    }

    public void Soft()
    {
        if (Thread.CurrentThread == thread)
        {
            thread_complete_soft = true;
        }
        else
        {
            throw new Exception("Команда не выполняется в текущем потоке");
        }
    }
}
public class SoftStop : ICommand
{
    public void Execute()
    {
        new ServerThread().Soft();
    }
}
public class HardStop : ICommand
{
    public void Execute()
    {
        new ServerThread().Hard();
    }
}
public class Test_1 : ICommand
{
    public void Execute()
    {
        Console.WriteLine("1 тест");
    }
}
public class Test_2 : ICommand
{
    public void Execute()
    {
        Console.WriteLine("2 тест");
    }
}
public class Test_3 : ICommand
{
    public void Execute()
    {
        Console.WriteLine("3 тест");
    }
}

#!markdown

**Проверка**, гарантирующая правильность выполнения **HardStop и SoftStop**

#!csharp

ServerThread serverThread = new ServerThread();
serverThread.Start();
serverThread.AddComand(new Test_1());
serverThread.AddComand(new Test_2());
serverThread.AddComand(new SoftStop()); 
//serverThread.AddComand(new HardStop()); 
serverThread.AddComand(new Test_3());

#!markdown

Проверка при **SoftStop**        

Output:

1 тест

2 тест

3 тест

#!markdown

Проверка при **HardStop**

Output:

1 тест

2 тест
